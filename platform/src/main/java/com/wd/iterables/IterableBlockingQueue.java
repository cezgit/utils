package com.wd.iterables;

import java.util.Iterator;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * This class should be used as an "iterable" by consumers and a queue by producers.
 * Unlike a normal blocking queue, the iterator will BLOCK on hasNext rather than returning false
 * which allows this type to work like a buffer.
 * <p>
 * Multiple calls to iterator() will return different iterators with the same thread-safe backing data
 * Which would allow multiple consumer threads to share the work generated by any number of producers adding to this queue.
 * <p>
 * Consumers will continue to iterate until producers call the "done()" method.
 */
public class IterableBlockingQueue<T> implements Iterable<T> {

    private Queue<T> queue = new ConcurrentLinkedQueue<T>();
    private boolean isDone = false;

    private final Object monitor = new Object();

    public void done() {
        synchronized (monitor) {
            isDone = true;
            monitor.notify();
        }
    }

    public void add(T object) {
        synchronized (monitor) {
            queue.add(object);
            monitor.notify();
        }
    }

    public Integer size() {
        return queue.size();
    }

    @Override
    public Iterator<T> iterator() {
        return new Iterator<T>() {
            @Override
            public boolean hasNext() {
                try {
                    while (queue.isEmpty() && !isDone) {
                        synchronized (monitor) {
                            monitor.wait(150);
                        }
                    }
                } catch (InterruptedException e) {
                }
                return !(queue.isEmpty() && isDone);
            }

            @Override
            public T next() {
                synchronized (monitor) {
                    final T thing = queue.remove();
                    monitor.notify();
                    return thing;
                }
            }

            @Override
            public void remove() {
                synchronized (monitor) {
                    queue.remove();
                    monitor.notify();
                }
            }
        };
    }
}
